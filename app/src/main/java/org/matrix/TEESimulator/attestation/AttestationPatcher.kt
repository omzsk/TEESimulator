package org.matrix.TEESimulator.attestation

import java.nio.charset.StandardCharsets
import java.security.cert.Certificate
import java.security.cert.X509Certificate
import org.bouncycastle.asn1.*
import org.bouncycastle.asn1.x509.Extension
import org.bouncycastle.cert.X509CertificateHolder
import org.bouncycastle.cert.X509v3CertificateBuilder
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder
import org.matrix.TEESimulator.config.ConfigurationManager
import org.matrix.TEESimulator.logging.SystemLogger
import org.matrix.TEESimulator.pki.KeyBox
import org.matrix.TEESimulator.pki.KeyBoxManager
import org.matrix.TEESimulator.util.toHex

/**
 * Handles the modification (patching) of Android Key Attestation extensions within certificates.
 *
 * This object's primary function is to take a certificate chain generated by the real TEE, replace
 * its attestation data with simulated values, and then re-sign the leaf certificate with a custom
 * key, building a new, valid certificate chain.
 */
object AttestationPatcher {

    /**
     * Patches a full certificate chain by modifying the leaf's attestation and rebuilding the chain
     * with the correct custom signing certificates. This is the single entry point for patching.
     *
     * @param originalChain The original certificate chain from the hardware. The leaf must be at
     *   index 0.
     * @param uid The UID of the application requesting the certificate.
     * @return A new, cryptographically valid, patched certificate chain. Returns the original chain
     *   on any failure.
     */
    fun patchCertificateChain(originalChain: Array<Certificate>?, uid: Int): Array<Certificate> {
        if (originalChain.isNullOrEmpty()) {
            SystemLogger.error("Attempted to patch a null or empty certificate chain for UID $uid.")
            return originalChain ?: emptyArray()
        }

        return runCatching {
                val originalLeaf = originalChain[0] as X509Certificate
                val originalLeafHolder = X509CertificateHolder(originalLeaf.encoded)

                // 1. Attempt to parse the existing attestation extension. If it doesn't exist,
                // there's nothing to patch.
                val parsedAttestation =
                    parseAttestationExtension(originalLeafHolder) ?: return originalChain

                // 2. Get the appropriate keybox for the given algorithm to sign the new
                // certificate.
                val algorithm = originalLeaf.publicKey.algorithm
                val keybox = getKeyboxForUidAndAlgorithm(uid, algorithm)

                // 3. Create the new, patched leaf certificate.
                val patchedLeaf =
                    createPatchedLeafCertificate(
                        originalLeafHolder,
                        parsedAttestation,
                        keybox,
                        originalLeaf.sigAlgName,
                    )

                // 4. Construct the NEW, VALID chain by prepending the patched leaf to the keybox's
                // chain.
                val newChain = listOf(patchedLeaf) + keybox.certificates

                SystemLogger.info(
                    "Successfully rebuilt a valid, patched certificate chain for UID $uid."
                )
                newChain.toTypedArray()
            }
            .getOrElse {
                SystemLogger.error(
                    "Failed to patch and rebuild certificate chain for UID $uid.",
                    it,
                )
                originalChain // Return the original chain on any error.
            }
    }

    /**
     * Creates a new leaf certificate with a modified attestation extension.
     *
     * @param originalLeafHolder A Bouncy Castle holder for the original leaf certificate.
     * @param parsedAttestation The parsed components of the original attestation.
     * @param keybox The KeyBox containing the new issuer certificate and signing key.
     * @param sigAlgName The signature algorithm name (e.g., "SHA256withECDSA") from the original
     *   certificate. This is required to ensure the new certificate is signed using a compatible
     *   algorithm.
     * @return A new [Certificate] object.
     */
    private fun createPatchedLeafCertificate(
        originalLeafHolder: X509CertificateHolder,
        parsedAttestation: ParsedAttestation,
        keybox: KeyBox,
        sigAlgName: String,
    ): Certificate {
        // The issuer of our new leaf is the subject of the first certificate in our custom keybox
        // chain.
        val newIssuer = X509CertificateHolder(keybox.certificates[0].encoded).subject

        val builder =
            X509v3CertificateBuilder(
                newIssuer,
                originalLeafHolder.serialNumber,
                originalLeafHolder.notBefore,
                originalLeafHolder.notAfter,
                originalLeafHolder.subject,
                originalLeafHolder.subjectPublicKeyInfo,
            )

        // Create the new, patched attestation extension.
        val patchedExtension = createPatchedAttestationExtension(parsedAttestation)

        // Copy all other extensions from the original certificate, except for the attestation.
        originalLeafHolder.extensions.extensionOIDs.forEach {
            builder.addExtension(
                if (it == ATTESTATION_OID) patchedExtension else originalLeafHolder.getExtension(it)
            )
        }

        // Sign the newly built certificate with the private key from our keybox.
        val signer = JcaContentSignerBuilder(sigAlgName).build(keybox.keyPair.private)

        return JcaX509CertificateConverter().getCertificate(builder.build(signer))
    }

    private fun getKeyboxForUidAndAlgorithm(uid: Int, algorithm: String): KeyBox {
        val keyboxFile = ConfigurationManager.getKeyboxFileForUid(uid)
        return KeyBoxManager.getAttestationKey(keyboxFile, algorithm)
            ?: throw IllegalArgumentException(
                "No keybox found for UID $uid and algorithm $algorithm in file $keyboxFile"
            )
    }

    /** Recursively formats an ASN1Primitive into a concise, readable string. */
    fun formatAsn1Primitive(obj: ASN1Encodable?): String {
        val primitive = obj?.toASN1Primitive()
        return when (primitive) {
            null -> "NULL"
            is ASN1Integer -> primitive.value.toString()
            is ASN1Enumerated -> primitive.value.toString()
            is ASN1Boolean -> primitive.isTrue.toString()
            is ASN1Null -> "NULL"
            is ASN1OctetString -> {
                val bytes = primitive.octets
                // Attempt to decode as a printable string, otherwise show hex
                if (bytes.all { it >= 32 && it < 127 }) {
                    "\"${String(bytes, StandardCharsets.UTF_8)}\""
                } else if (bytes.isEmpty()) {
                    "\"\""
                } else {
                    "#" + bytes.toHex()
                }
            }
            is ASN1TaggedObject ->
                "[TAG ${primitive.tagNo}]${formatAsn1Primitive(primitive.baseObject)}"
            is ASN1Sequence ->
                primitive
                    .map { formatAsn1Primitive(it) }
                    .joinToString(prefix = "[", postfix = "]", separator = ", ")
            is ASN1Set ->
                primitive
                    .map { formatAsn1Primitive(it) }
                    .joinToString(prefix = "{", postfix = "}", separator = ", ")
            else -> primitive.toString() // Fallback for other types
        }
    }

    /** Parses the critical components from an existing attestation extension. */
    private fun parseAttestationExtension(certHolder: X509CertificateHolder): ParsedAttestation? {
        val extension = certHolder.getExtension(ATTESTATION_OID) ?: return null
        val sequence = ASN1Sequence.getInstance(extension.extnValue.octets)
        val allFields = sequence.toArray()
        val teeEnforced =
            allFields[AttestationConstants.KEY_DESCRIPTION_TEE_ENFORCED_INDEX] as ASN1Sequence

        var originalRootOfTrust: ASN1Encodable? = null
        val teeEnforcedMap = mutableMapOf<Int, ASN1TaggedObject>()

        teeEnforced.forEach { element ->
            val taggedObject = element as ASN1TaggedObject
            if (taggedObject.tagNo == AttestationConstants.TAG_ROOT_OF_TRUST) {
                originalRootOfTrust = taggedObject.baseObject.toASN1Primitive()
            } else {
                teeEnforcedMap[taggedObject.tagNo] = taggedObject
            }
        }
        return ParsedAttestation(allFields, teeEnforcedMap, originalRootOfTrust)
    }

    /** Constructs a new, patched attestation extension using simulated device properties. */
    private fun createPatchedAttestationExtension(parsed: ParsedAttestation): Extension {
        val (allFields, teeEnforcedMap, originalRootOfTrust) = parsed

        var formattedString = allFields.joinToString(separator = ", ") { formatAsn1Primitive(it) }
        SystemLogger.verbose("Original attestation data: ${formattedString}")

        // Build the new Root of Trust and add/replace it in the map.
        val newRootOfTrust = AttestationBuilder.buildRootOfTrust(originalRootOfTrust)
        teeEnforcedMap[AttestationConstants.TAG_ROOT_OF_TRUST] =
            DERTaggedObject(true, AttestationConstants.TAG_ROOT_OF_TRUST, newRootOfTrust)

        // Add other simulated hardware properties.
        teeEnforcedMap.putAll(AttestationBuilder.getSimulatedHardwareProperties())

        // Re-assemble the TEE enforced list from the map's values, sorting for DER compliance.
        val sortedElements = teeEnforcedMap.values.sortedBy { it.tagNo }
        val sortedTeeEnforced = DERSequence(sortedElements.toTypedArray())

        allFields[AttestationConstants.KEY_DESCRIPTION_TEE_ENFORCED_INDEX] = sortedTeeEnforced
        val patchedSequence = DERSequence(allFields)
        formattedString = patchedSequence.joinToString(separator = ", ") { formatAsn1Primitive(it) }
        SystemLogger.verbose("Patched  attestation data: ${formattedString}")
        val patchedOctets = DEROctetString(patchedSequence)

        return Extension(ATTESTATION_OID, false, patchedOctets)
    }

    /** Helper data class to hold the parsed components of an attestation extension. */
    private data class ParsedAttestation(
        val allFields: Array<ASN1Encodable>,
        val teeEnforcedMap: MutableMap<Int, ASN1TaggedObject>,
        val rootOfTrust: ASN1Encodable?,
    )
}
